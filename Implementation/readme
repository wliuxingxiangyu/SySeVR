Environment:
joern 0.3.1, neo4j 2.1.5, python 3.6, tensorflow 1.6, gensim 3.4

Step 1: Generating slices (i.e., SeVCs)
`
(1) Use joern to parse source code: the input is source code files, and the output is a file named .joernIndex.
joern(-core)主要用来进行代码的解析以及以代码属性图形式进行存储。
~/ws/other/0vul/joern/$ wget https://github.com/fabsx00/joern/archive/0.3.1.tar.gz
~/ws/other/0vul/joern/$ tar xfzv 0.3.1.tar.gz
~/ws/other/0vul/joern/$ cd joern-0.3.1
~/ws/other/0vul/joern/joern-0.3.1$ ant
~/ws/other/0vul/joern/joern-0.3.1/bin$ java -version
java version "1.7.0_80"
~/ws/other/0vul/joern/joern-0.3.1/bin$ java -jar joern.jar $CodeDirectory
代码属性图 存入 数据库 ~/ws/other/0vul/joern/joern-0.3.1/.joernIndex

neo4j-community-2.1.8图形数据库管理界面。
aw "http://neo4j.com/artifact.php?name=neo4j-community-2.1.8-unix.tar.gz"
tar -zxvf neo4j-community-2.1.8-unix.tar.gz

~/ws/other/0vul/neo4j-community-2.1.8/bin$ ./neo4j status
~/ws/other/0vul/neo4j-community-2.1.8/bin$ ./neo4j start-no-wait
`

(2) get_cfg_relation.py: This file is used to get CFG graphs of functions using joern tool. The input is output of the first step, and the outputs are stored with folders in cfg_db. 
~/ws/other/0vul/SySeVR$ mkdir cfg_db
~/ws/other/0vul/SySeVR$ cd cfg_db
~/ws/other/0vul/SySeVR$ mkdir testCode
~/ws/other/0vul/SySeVR$ py2 Implementation/source2slice/get_cfg_relation.py

(3) complete_PDG.py: This file is used to get PDG graph of functions. The inputs are files in cfg_db, and the outputs are stored with folders in pdg_db.
~/ws/other/0vul/SySeVR$ mkdir pdg_db
~/ws/other/0vul/SySeVR$ cd pdg_db
~/ws/other/0vul/SySeVR$ mkdir testCode
~/ws/other/0vul/SySeVR$ py2 Implementation/source2slice/complete_PDG.py

(4) access_db_operate.py: This file is used to get the call graph of functions. The inputs are files in pdg_db, and the outputs are stored with folders in dict_call2cfgNodeID_funcID.
~/ws/other/0vul/SySeVR$ py2 Implementation/source2slice/access_db_operate.py

['testCode']
hz-, access_db_operate.py, list_all_func_node=False
Traceback (most recent call last):
  File "Implementation/source2slice/access_db_operate.py", line 705, in <module>
    call_g = getCallGraph(j, testID)
  File "Implementation/source2slice/access_db_operate.py", line 520, in getCallGraph
    for func_node in list_all_func_node:
TypeError: 'bool' object is not iterable

(5) points_get.py: This file is used to get four kinds of SyVCs. The inputs are files in dict_call2cfgNodeID_funcID, and the outputs are four kinds of SyVCs.

(6) extract_df.py: This file is used to extract slices. The inputs are files generated by points_get.py, and the outputs are slice files.

(7) make_label.py: This file is used to get labels of slices.

(8) data_preprocess.py: This file is used to write the labels to the slice files.

Step 2: Data preprocess

(1) process_dataflow_func.py: This file is used to process the slices, including read the pkl file and split codes into corpus. The inputs are the slice file and the label file, and the output is the corpus file named with testcase id.

(2) create_w2vmodel.py: This file is used to train word2vec model. The inputs are corpus files, and the output is the word2vec model.

(3) get_dl_input.py: This file is used to convert tokens of slices in corpus files into vectors by trained word2vec model. The input is the trained word2vec model and corpus files, and the outputs are vector files.

(4) dealrawdata.py: This file is used to make vectors generated by get_dl_input.py into fixed length. 

Step 3: Deep Learning Model

(1) bgru.py: This file is used to train BGRU model and get test results. The inputs are vector files generated by dealrawdata.py, and the output is trained model and test results.

(2) preprocess_dl_Input_version5.py: This file is used to preprocess data imported into model. It is imported by bgru.py.
